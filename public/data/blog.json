[
    {
        "id": 1,
        "slug": "building-modern-android-apps-jetpack-compose",
        "title": "Building Modern Android Apps with Jetpack Compose",
        "date": "2025-01-05",
        "author": "Olorunfemi John",
        "category": "mobile",
        "tags": [
            "Android",
            "Kotlin",
            "Jetpack Compose",
            "Mobile Development"
        ],
        "excerpt": "Discover how Jetpack Compose revolutionizes Android UI development with declarative programming and Material 3 design.",
        "readingTime": 8,
        "featured": true,
        "thumbnail": "/blog/android-compose-thumb.jpg",
        "content": "<article><p>Jetpack Compose has fundamentally changed how we build Android UIs. Moving from XML layouts to a fully declarative approach not only makes code more readable but also significantly reduces boilerplate.</p><h2>Why Jetpack Compose?</h2><p>Traditional Android development required managing complex XML layouts, view binding, and lifecycle-aware components. Compose simplifies this with a single programming model.</p><h3>Key Benefits</h3><ul><li><strong>Declarative UI:</strong> Describe what your UI should look like, not how to build it</li><li><strong>Less Code:</strong> Eliminate findViewById and view binding</li><li><strong>Kotlin-First:</strong> Leverage Kotlin's full power including coroutines</li><li><strong>Material 3:</strong> Built-in support for the latest Material Design</li></ul><h2>Getting Started</h2><p>Here's a simple example of a composable function:</p><pre><code class='language-kotlin'>@Composable\nfun Greeting(name: String) {\n    Text(\n        text = \"Hello $name!\",\n        style = MaterialTheme.typography.headlineMedium,\n        color = MaterialTheme.colorScheme.primary\n    )\n}</code></pre><h2>State Management</h2><p>Compose makes state management intuitive with <code>remember</code> and <code>mutableStateOf</code>:</p><pre><code class='language-kotlin'>@Composable\nfun Counter() {\n    var count by remember { mutableStateOf(0) }\n    \n    Button(onClick = { count++ }) {\n        Text(\"Clicked $count times\")\n    }\n}</code></pre><h2>Real-World Application</h2><p>In my HabitFlow app, I used Compose to create a beautiful Material You interface with dynamic theming, smooth animations, and complex state management—all with significantly less code than the traditional approach would require.</p><h2>Conclusion</h2><p>Jetpack Compose is the future of Android development. If you're starting a new project, there's no reason not to use it. The learning curve is worth it for the productivity gains and modern development experience.</p></article>"
    },
    {
        "id": 2,
        "slug": "chrome-extension-manifest-v3-migration",
        "title": "Chrome Extension Manifest V3: What You Need to Know",
        "date": "2024-12-28",
        "author": "Olorunfemi John",
        "category": "web",
        "tags": [
            "Chrome Extensions",
            "JavaScript",
            "Web Development",
            "Manifest V3"
        ],
        "excerpt": "A practical guide to migrating your Chrome extensions from Manifest V2 to V3, with real-world examples and solutions to common challenges.",
        "readingTime": 10,
        "featured": true,
        "thumbnail": "/blog/chrome-extension-thumb.jpg",
        "content": "<article><p>Google's push to Manifest V3 has been controversial, but it's here to stay. After migrating my Keyword Scout extension, I learned valuable lessons about the new architecture.</p><h2>Major Changes</h2><h3>1. Service Workers Replace Background Pages</h3><p>The biggest change is moving from persistent background pages to service workers that can be terminated when idle.</p><pre><code class='language-json'>// manifest.json\n{\n  \"manifest_version\": 3,\n  \"background\": {\n    \"service_worker\": \"background.js\"\n  }\n}</code></pre><h3>2. No More Remote Code Execution</h3><p>All code must be bundled with the extension. This affects:</p><ul><li>External scripts (must be bundled)</li><li>Inline scripts (must move to separate files)</li><li>eval() and similar functions (prohibited)</li></ul><h3>3. Declarative Net Request API</h3><p>The webRequest API is being replaced with declarativeNetRequest for better privacy and performance.</p><h2>Migration Strategy</h2><h3>Step 1: Update Manifest</h3><pre><code class='language-json'>{\n  \"manifest_version\": 3,\n  \"name\": \"My Extension\",\n  \"version\": \"2.0\",\n  \"permissions\": [\"storage\", \"activeTab\"],\n  \"host_permissions\": [\"https://*.example.com/*\"]\n}</code></pre><h3>Step 2: Refactor Background Scripts</h3><p>Service workers don't have access to DOM or window object. Store data using chrome.storage API:</p><pre><code class='language-javascript'>// Store data\nawait chrome.storage.local.set({ key: value });\n\n// Retrieve data\nconst { key } = await chrome.storage.local.get('key');</code></pre><h3>Step 3: Handle Service Worker Lifecycle</h3><p>Since service workers can be terminated, use alarms for periodic tasks:</p><pre><code class='language-javascript'>chrome.alarms.create('myAlarm', { periodInMinutes: 5 });\n\nchrome.alarms.onAlarm.addListener((alarm) => {\n  if (alarm.name === 'myAlarm') {\n    // Do periodic work\n  }\n});</code></pre><h2>Common Pitfalls</h2><ol><li><strong>Assuming persistence:</strong> Don't rely on global variables; they'll be lost when the service worker terminates</li><li><strong>Synchronous storage:</strong> chrome.storage is now promise-based; use async/await</li><li><strong>Content script injection:</strong> Use scripting API instead of tabs.executeScript</li></ol><h2>Benefits</h2><p>Despite the migration pain, V3 brings real improvements:</p><ul><li>Better performance (service workers use less memory)</li><li>Enhanced security (no remote code execution)</li><li>Improved privacy (declarative net request)</li><li>Modern JavaScript (native promises, async/await)</li></ul><h2>Conclusion</h2><p>Manifest V3 requires rethinking extension architecture, but the result is more robust and efficient. Start migrating now—V2 extensions will eventually be deprecated.</p></article>"
    },
    {
        "id": 3,
        "slug": "web-performance-optimization-techniques",
        "title": "Web Performance Optimization: Beyond the Basics",
        "date": "2024-12-15",
        "author": "Olorunfemi John",
        "category": "web",
        "tags": [
            "Performance",
            "Web Development",
            "Optimization",
            "JavaScript"
        ],
        "excerpt": "Advanced techniques for achieving blazing-fast web applications, from code splitting to resource hints and beyond.",
        "readingTime": 12,
        "featured": false,
        "thumbnail": "/blog/performance-thumb.jpg",
        "content": "<article><p>Performance isn't just about fast load times—it's about creating smooth, responsive experiences that keep users engaged. Here are advanced techniques I use to optimize web applications.</p><h2>1. Code Splitting & Lazy Loading</h2><p>Don't ship code users don't need immediately. Use dynamic imports:</p><pre><code class='language-javascript'>// Load heavy component only when needed\nconst HeavyChart = lazy(() => import('./HeavyChart'));\n\nfunction Dashboard() {\n  return (\n    &lt;Suspense fallback={&lt;Spinner /&gt;}&gt;\n      &lt;HeavyChart /&gt;\n    &lt;/Suspense&gt;\n  );\n}</code></pre><h2>2. Resource Hints</h2><p>Tell the browser what to fetch before it's needed:</p><pre><code class='language-html'>&lt;!-- Preconnect to external domains --&gt;\n&lt;link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"&gt;\n\n&lt;!-- Prefetch resources for next page --&gt;\n&lt;link rel=\"prefetch\" href=\"/next-page.js\"&gt;\n\n&lt;!-- Preload critical resources --&gt;\n&lt;link rel=\"preload\" href=\"hero.jpg\" as=\"image\"&gt;</code></pre><h2>3. Image Optimization</h2><h3>Modern Formats</h3><p>Use WebP or AVIF with fallbacks:</p><pre><code class='language-html'>&lt;picture&gt;\n  &lt;source srcset=\"image.avif\" type=\"image/avif\"&gt;\n  &lt;source srcset=\"image.webp\" type=\"image/webp\"&gt;\n  &lt;img src=\"image.jpg\" alt=\"Description\"&gt;\n&lt;/picture&gt;</code></pre><h3>Lazy Loading</h3><pre><code class='language-html'>&lt;img src=\"image.jpg\" loading=\"lazy\" alt=\"Description\"&gt;</code></pre><h2>4. JavaScript Optimization</h2><h3>Debouncing & Throttling</h3><pre><code class='language-javascript'>// Debounce: Wait for user to stop typing\nconst debounce = (fn, delay) => {\n  let timeout;\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn(...args), delay);\n  };\n};\n\n// Throttle: Limit execution rate\nconst throttle = (fn, limit) => {\n  let inThrottle;\n  return (...args) => {\n    if (!inThrottle) {\n      fn(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n};</code></pre><h2>5. CSS Performance</h2><ul><li>Use CSS containment: <code>contain: layout style paint;</code></li><li>Avoid expensive properties: box-shadow, filter, opacity on large elements</li><li>Use transform and opacity for animations (GPU-accelerated)</li><li>Critical CSS inline, rest async</li></ul><h2>6. Monitoring & Metrics</h2><p>Track Core Web Vitals:</p><ul><li><strong>LCP (Largest Contentful Paint):</strong> &lt; 2.5s</li><li><strong>FID (First Input Delay):</strong> &lt; 100ms</li><li><strong>CLS (Cumulative Layout Shift):</strong> &lt; 0.1</li></ul><pre><code class='language-javascript'>// Measure performance\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    console.log(entry.name, entry.startTime);\n  }\n});\nobserver.observe({ entryTypes: ['measure', 'navigation'] });</code></pre><h2>Real-World Results</h2><p>Applying these techniques to my portfolio:</p><ul><li>Lighthouse score: 100/100</li><li>First Contentful Paint: &lt; 0.8s</li><li>Time to Interactive: &lt; 1.5s</li><li>Bundle size: &lt; 50KB (gzipped)</li></ul><h2>Conclusion</h2><p>Performance optimization is an ongoing process. Measure, optimize, and measure again. Your users will thank you with better engagement and conversion rates.</p></article>"
    },
    {
        "id": 4,
        "slug": "understanding-android-system-hooks",
        "title": "Deep Dive: Android System Hooks with LSPosed",
        "date": "2024-11-20",
        "author": "Olorunfemi John",
        "category": "mobile",
        "tags": [
            "Android",
            "LSPosed",
            "Xposed",
            "System Programming"
        ],
        "excerpt": "Exploring the internals of Android system modification through LSPosed framework, with practical examples from real projects.",
        "readingTime": 15,
        "featured": false,
        "thumbnail": "/blog/android-hooks-thumb.jpg",
        "content": "<article><p>LSPosed (and its predecessor Xposed) allows developers to modify Android system behavior at runtime without modifying APKs. This opens up powerful possibilities for customization and research.</p><h2>How It Works</h2><p>LSPosed hooks into the Zygote process (the parent of all Android apps) and intercepts method calls, allowing you to:</p><ul><li>Modify method parameters</li><li>Change return values</li><li>Execute code before/after methods</li><li>Replace entire method implementations</li></ul><h2>Basic Hook Structure</h2><pre><code class='language-java'>public class MyHook implements IXposedHookLoadPackage {\n    @Override\n    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) {\n        if (!lpparam.packageName.equals(\"com.target.app\"))\n            return;\n            \n        XposedHelpers.findAndHookMethod(\n            \"com.target.app.MainActivity\",\n            lpparam.classLoader,\n            \"targetMethod\",\n            String.class,\n            new XC_MethodHook() {\n                @Override\n                protected void beforeHookedMethod(MethodHookParam param) {\n                    // Modify parameters\n                    param.args[0] = \"Modified value\";\n                }\n                \n                @Override\n                protected void afterHookedMethod(MethodHookParam param) {\n                    // Modify return value\n                    param.setResult(\"New result\");\n                }\n            }\n        );\n    }\n}</code></pre><h2>Real-World Example: SMS Interception</h2><p>In my SMS Hook module, I intercept outgoing SMS at the framework level:</p><pre><code class='language-java'>// Hook SmsManager.sendTextMessage\nXposedHelpers.findAndHookMethod(\n    \"android.telephony.SmsManager\",\n    lpparam.classLoader,\n    \"sendTextMessageInternal\",\n    String.class, String.class, String.class,\n    PendingIntent.class, PendingIntent.class,\n    boolean.class, int.class, boolean.class, int.class,\n    new XC_MethodHook() {\n        @Override\n        protected void beforeHookedMethod(MethodHookParam param) {\n            String originalText = (String) param.args[2];\n            String appendText = getAppendText();\n            \n            // Modify SMS text\n            param.args[2] = originalText + appendText;\n            \n            XposedBridge.log(\"SMS intercepted: \" + originalText);\n        }\n    }\n);</code></pre><h2>Camera Interception</h2><p>My Camera Hook module demonstrates hooking multiple camera APIs:</p><pre><code class='language-java'>// Hook legacy Camera API\nXposedHelpers.findAndHookMethod(\n    \"android.hardware.Camera\",\n    lpparam.classLoader,\n    \"takePicture\",\n    Camera.ShutterCallback.class,\n    Camera.PictureCallback.class,\n    Camera.PictureCallback.class,\n    new XC_MethodHook() {\n        @Override\n        protected void beforeHookedMethod(MethodHookParam param) {\n            // Replace callback with custom implementation\n            Camera.PictureCallback originalCallback = \n                (Camera.PictureCallback) param.args[2];\n            \n            param.args[2] = (data, camera) -> {\n                // Inject custom image data\n                byte[] customImage = loadCustomImage();\n                originalCallback.onPictureTaken(customImage, camera);\n            };\n        }\n    }\n);</code></pre><h2>Best Practices</h2><ol><li><strong>Minimal Scope:</strong> Only hook what you need</li><li><strong>Error Handling:</strong> Wrap hooks in try-catch to prevent crashes</li><li><strong>Performance:</strong> Hooks execute on every call; keep them fast</li><li><strong>Compatibility:</strong> Test across Android versions</li><li><strong>Logging:</strong> Use XposedBridge.log for debugging</li></ol><h2>Security Considerations</h2><p>System hooks are powerful but come with responsibility:</p><ul><li>Only use on devices you own</li><li>Respect user privacy</li><li>Don't bypass app security for malicious purposes</li><li>Understand the legal implications</li></ul><h2>Debugging Tips</h2><pre><code class='language-java'>// Enable detailed logging\nXposedBridge.log(\"Hook triggered: \" + param.method.getName());\n\n// Log all parameters\nfor (int i = 0; i &lt; param.args.length; i++) {\n    XposedBridge.log(\"Arg \" + i + \": \" + param.args[i]);\n}\n\n// Catch exceptions\ntry {\n    // Hook logic\n} catch (Throwable t) {\n    XposedBridge.log(\"Hook error: \" + t.getMessage());\n}</code></pre><h2>Conclusion</h2><p>LSPosed opens up Android's internals for customization and research. While powerful, it requires deep understanding of Android framework and responsible usage. Use it to learn, experiment, and create useful tools—never for harm.</p></article>"
    },
    {
        "id": 5,
        "slug": "typescript-best-practices-2025",
        "title": "TypeScript Best Practices for 2025",
        "date": "2024-11-08",
        "author": "Olorunfemi John",
        "category": "web",
        "tags": [
            "TypeScript",
            "JavaScript",
            "Best Practices",
            "Web Development"
        ],
        "excerpt": "Modern TypeScript patterns and practices that will make your code more maintainable, type-safe, and enjoyable to work with.",
        "readingTime": 10,
        "featured": false,
        "thumbnail": "/blog/typescript-thumb.jpg",
        "content": "<article><p>TypeScript has evolved significantly. Here are the patterns and practices I use in production projects to write better, more maintainable code.</p><h2>1. Strict Mode is Non-Negotiable</h2><pre><code class='language-json'>// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}</code></pre><h2>2. Use Type Inference</h2><p>Let TypeScript infer types when possible:</p><pre><code class='language-typescript'>// ❌ Redundant\nconst name: string = \"John\";\n\n// ✅ Better\nconst name = \"John\";\n\n// ❌ Redundant\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// ✅ Better (return type inferred)\nfunction add(a: number, b: number) {\n  return a + b;\n}</code></pre><h2>3. Discriminated Unions</h2><p>Perfect for state management and API responses:</p><pre><code class='language-typescript'>type ApiResponse&lt;T&gt; =\n  | { status: 'loading' }\n  | { status: 'success'; data: T }\n  | { status: 'error'; error: string };\n\nfunction handleResponse&lt;T&gt;(response: ApiResponse&lt;T&gt;) {\n  switch (response.status) {\n    case 'loading':\n      return &lt;Spinner /&gt;;\n    case 'success':\n      return &lt;Data data={response.data} /&gt;;\n    case 'error':\n      return &lt;Error message={response.error} /&gt;;\n  }\n}</code></pre><h2>4. Utility Types</h2><p>Master the built-in utility types:</p><pre><code class='language-typescript'>interface User {\n  id: string;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\n// Pick specific properties\ntype UserPreview = Pick&lt;User, 'id' | 'name'&gt;;\n\n// Omit properties\ntype UserWithoutEmail = Omit&lt;User, 'email'&gt;;\n\n// Make all properties optional\ntype PartialUser = Partial&lt;User&gt;;\n\n// Make all properties required\ntype RequiredUser = Required&lt;User&gt;;\n\n// Make all properties readonly\ntype ReadonlyUser = Readonly&lt;User&gt;;</code></pre><h2>5. Generic Constraints</h2><pre><code class='language-typescript'>// Constrain to objects with id property\nfunction findById&lt;T extends { id: string }&gt;(\n  items: T[],\n  id: string\n): T | undefined {\n  return items.find(item => item.id === id);\n}\n\n// Constrain to specific keys\nfunction getProperty&lt;T, K extends keyof T&gt;(\n  obj: T,\n  key: K\n): T[K] {\n  return obj[key];\n}</code></pre><h2>6. Template Literal Types</h2><pre><code class='language-typescript'>type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\ntype Endpoint = '/users' | '/posts' | '/comments';\n\n// Generate all combinations\ntype ApiRoute = `${HttpMethod} ${Endpoint}`;\n// Result: 'GET /users' | 'POST /users' | ... (12 combinations)\n\n// CSS properties\ntype CSSProperty = `${'margin' | 'padding'}-${'top' | 'bottom' | 'left' | 'right'}`;\n// Result: 'margin-top' | 'margin-bottom' | ...</code></pre><h2>7. Type Guards</h2><pre><code class='language-typescript'>// User-defined type guard\nfunction isUser(obj: unknown): obj is User {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    'id' in obj &&\n    'name' in obj\n  );\n}\n\n// Usage\nfunction processData(data: unknown) {\n  if (isUser(data)) {\n    // TypeScript knows data is User here\n    console.log(data.name);\n  }\n}</code></pre><h2>8. Const Assertions</h2><pre><code class='language-typescript'>// Without const assertion\nconst colors = ['red', 'green', 'blue'];\n// Type: string[]\n\n// With const assertion\nconst colors = ['red', 'green', 'blue'] as const;\n// Type: readonly ['red', 'green', 'blue']\n\n// Object const assertion\nconst config = {\n  api: 'https://api.example.com',\n  timeout: 5000\n} as const;\n// All properties become readonly</code></pre><h2>9. Branded Types</h2><p>Create distinct types from primitives:</p><pre><code class='language-typescript'>type UserId = string & { __brand: 'UserId' };\ntype PostId = string & { __brand: 'PostId' };\n\nfunction getUser(id: UserId) { /* ... */ }\nfunction getPost(id: PostId) { /* ... */ }\n\nconst userId = '123' as UserId;\nconst postId = '456' as PostId;\n\ngetUser(userId);  // ✅ OK\ngetUser(postId);  // ❌ Error: Type 'PostId' is not assignable to 'UserId'</code></pre><h2>10. Avoid 'any'</h2><p>Use 'unknown' instead:</p><pre><code class='language-typescript'>// ❌ Bad\nfunction process(data: any) {\n  return data.value; // No type checking\n}\n\n// ✅ Good\nfunction process(data: unknown) {\n  if (typeof data === 'object' && data !== null && 'value' in data) {\n    return (data as { value: string }).value;\n  }\n  throw new Error('Invalid data');\n}</code></pre><h2>Conclusion</h2><p>These patterns have saved me countless hours of debugging and made my code more maintainable. TypeScript's type system is powerful—use it to your advantage!</p></article>"
    }
]